use anchor_lang::prelude::sysvar::instructions::load_instruction_at_checked;
use anchor_lang::prelude::*;

use anchor_lang::solana_program::sysvar::instructions::load_current_index_checked;
use anchor_spl::token_interface;

use crate::borrow::BORROW_DISCRIMINATOR;
use crate::error::ErrorCode;
use crate::instructions::{BORROWER_ATA_INDEX, PROTOCOL_ATA_INDEX};
use crate::{Loan, ID};

/// The 8-byte discriminator for the repay instruction
/// Generated by Anchor as the first 8 bytes of BLAKE3("global:repay")
pub const REPAY_DISCRIMINATOR: &[u8] = &[234, 103, 67, 82, 208, 234, 219, 166];

pub fn handler(ctx: Context<Loan>) -> Result<()> {
    let ixs = ctx.accounts.instructions.to_account_info();

    let mut amount_borrowed: u64;

    if let Ok(borrow_ix) = load_instruction_at_checked(0, &ixs) {
        // Instruction checks
        require_keys_eq!(borrow_ix.program_id, ID, ErrorCode::InvalidProgram);
        require!(
            borrow_ix.data[0..8].eq(BORROW_DISCRIMINATOR),
            ErrorCode::InvalidIx
        );

        let mut borrowed_data: [u8; 8] = [0u8; 8];
        borrowed_data.copy_from_slice(&borrow_ix.data[8..16]);
        amount_borrowed = u64::from_le_bytes(borrowed_data)
    } else {
        return Err(ErrorCode::MissingBorrowIx.into());
    }

    // Calculate fee based on protocol configuration (in basis points)
    let protocol_fee_bps = ctx.accounts.protocol.fee;
    let fee = (amount_borrowed as u128)
        .checked_mul(protocol_fee_bps as u128)
        .ok_or(ErrorCode::Overflow)?
        .checked_div(10_000)
        .ok_or(ErrorCode::Overflow)? as u64;
    amount_borrowed = amount_borrowed
        .checked_add(fee)
        .ok_or(ErrorCode::Overflow)?;

    token_interface::transfer(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            token_interface::Transfer {
                from: ctx.accounts.borrower_ata.to_account_info(),
                to: ctx.accounts.protocol_ata.to_account_info(),
                authority: ctx.accounts.borrower.to_account_info(),
            },
        ),
        amount_borrowed,
    )?;

    Ok(())
}

/// Checks the repay instruction exists in the transaction
pub fn repay_hook(ctx: &Context<Loan>) -> Result<()> {
    let ixs = ctx.accounts.instructions.to_account_info();
    let current_index = load_current_index_checked(&ctx.accounts.instructions)?;
    require_eq!(current_index, 0, ErrorCode::InvalidIx);

    let instruction_sysvar = ixs.try_borrow_data()?;
    let len = u16::from_le_bytes(instruction_sysvar[0..2].try_into().unwrap());

    // Ensure we have a repay ix
    if let Ok(repay_ix) = load_instruction_at_checked(len as usize - 1, &ixs) {
        // Instruction checks
        require_keys_eq!(repay_ix.program_id, ID, ErrorCode::InvalidProgram);
        require!(
            repay_ix.data[0..8].eq(REPAY_DISCRIMINATOR),
            ErrorCode::InvalidIx
        );
        require_keys_eq!(
            repay_ix
                .accounts
                .get(BORROWER_ATA_INDEX)
                .ok_or(ErrorCode::InvalidBorrowerAta)?
                .pubkey,
            ctx.accounts.borrower_ata.key(),
            ErrorCode::InvalidBorrowerAta
        );
        require_keys_eq!(
            repay_ix
                .accounts
                .get(PROTOCOL_ATA_INDEX)
                .ok_or(ErrorCode::InvalidProtocolAta)?
                .pubkey,
            ctx.accounts.protocol_ata.key(),
            ErrorCode::InvalidProtocolAta
        );
    } else {
        return Err(ErrorCode::MissingRepayIx.into());
    }

    Ok(())
}
